<!doctype html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cruce de Shibuya 3D · First Person</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #05070b;
    }
    #overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(circle at 50% 40%, rgba(23, 34, 62, 0.5), rgba(2, 5, 12, 0.92));
      color: #eff3ff;
      text-align: center;
      z-index: 20;
      transition: opacity 300ms ease;
    }
    #overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .panel {
      max-width: 680px;
      padding: 28px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 14px;
      background: rgba(6, 10, 23, 0.72);
      backdrop-filter: blur(6px);
      box-shadow: 0 20px 70px rgba(0, 0, 0, 0.45);
    }
    h1 { margin-top: 0; font-size: clamp(1.4rem, 2.8vw, 2.2rem); }
    p { line-height: 1.45; opacity: 0.93; }
    button {
      margin-top: 16px;
      border: 0;
      background: linear-gradient(90deg, #1fd6ff, #8d8eff);
      color: #07111d;
      font-weight: 700;
      font-size: 1rem;
      padding: 11px 20px;
      border-radius: 999px;
      cursor: pointer;
    }
    #hud {
      position: fixed;
      left: 14px;
      bottom: 14px;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(6, 9, 18, 0.58);
      color: #dce8ff;
      font-size: 0.84rem;
      border: 1px solid rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(4px);
      z-index: 10;
      user-select: none;
    }
    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 16px;
      height: 16px;
      margin-left: -8px;
      margin-top: -8px;
      z-index: 8;
      opacity: 0.75;
      pointer-events: none;
    }
    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(240, 246, 255, 0.9);
    }
    #crosshair::before { left: 7px; top: 0; width: 2px; height: 16px; }
    #crosshair::after { top: 7px; left: 0; width: 16px; height: 2px; }
  </style>
</head>
<body>
  <div id="overlay">
    <div class="panel">
      <h1>Cruce de Shibuya · Simulación 3D en primera persona</h1>
      <p>
        Muévete como en un FPS por el cruce más famoso de Tokio. Incluye tráfico, semáforos,
        peatones NPC con ciclos de cruce y una iluminación nocturna urbana inspirada en Shibuya.
      </p>
      <p><strong>WASD</strong> mover · <strong>Shift</strong> correr · <strong>Espacio</strong> saltar · <strong>Mouse</strong> mirar · <strong>Esc</strong> liberar cursor</p>
      <button id="startBtn">Entrar en la simulación</button>
    </div>
  </div>
  <div id="crosshair"></div>
  <div id="hud">Estado: Preparado</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050810);
    scene.fog = new THREE.FogExp2(0x050810, 0.0085);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(74, window.innerWidth / window.innerHeight, 0.1, 1400);
    camera.position.set(0, 1.72, 42);

    const controls = new PointerLockControls(camera, document.body);
    scene.add(controls.getObject());

    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const hud = document.getElementById('hud');

    startBtn.addEventListener('click', () => controls.lock());
    controls.addEventListener('lock', () => {
      overlay.classList.add('hidden');
      hud.textContent = 'Estado: Explorando Shibuya';
    });
    controls.addEventListener('unlock', () => {
      overlay.classList.remove('hidden');
      hud.textContent = 'Estado: Pausado (pulsa Entrar en la simulación)';
    });

    const hemi = new THREE.HemisphereLight(0x5d77b1, 0x111720, 0.68);
    scene.add(hemi);

    const moonLight = new THREE.DirectionalLight(0x9dc1ff, 1.25);
    moonLight.position.set(-95, 120, 70);
    moonLight.castShadow = true;
    moonLight.shadow.mapSize.set(2048, 2048);
    moonLight.shadow.camera.left = -160;
    moonLight.shadow.camera.right = 160;
    moonLight.shadow.camera.top = 160;
    moonLight.shadow.camera.bottom = -160;
    moonLight.shadow.camera.far = 320;
    scene.add(moonLight);

    const neonLightA = new THREE.PointLight(0x2df3ff, 8, 120, 2);
    neonLightA.position.set(-24, 14, -10);
    scene.add(neonLightA);

    const neonLightB = new THREE.PointLight(0xff3eef, 7, 120, 2);
    neonLightB.position.set(34, 12, 20);
    scene.add(neonLightB);

    function makeAsphaltTexture() {
      const c = document.createElement('canvas');
      c.width = c.height = 1024;
      const g = c.getContext('2d');
      g.fillStyle = '#2a2d33';
      g.fillRect(0, 0, c.width, c.height);
      for (let i = 0; i < 20000; i++) {
        const x = Math.random() * c.width;
        const y = Math.random() * c.height;
        const v = Math.floor(40 + Math.random() * 70);
        g.fillStyle = `rgb(${v},${v},${v})`;
        g.fillRect(x, y, 1.4, 1.4);
      }
      for (let i = 0; i < 400; i++) {
        g.strokeStyle = `rgba(255,255,255,${Math.random() * 0.05})`;
        g.beginPath();
        g.moveTo(Math.random() * c.width, Math.random() * c.height);
        g.lineTo(Math.random() * c.width, Math.random() * c.height);
        g.stroke();
      }
      const texture = new THREE.CanvasTexture(c);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(10, 10);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      return texture;
    }

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(600, 600),
      new THREE.MeshStandardMaterial({ map: makeAsphaltTexture(), roughness: 0.92, metalness: 0.07 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const worldBounds = 90;

    function crosswalkRect(x, z, width, length, rot = 0) {
      const group = new THREE.Group();
      const stripeMat = new THREE.MeshStandardMaterial({ color: 0xf4f4f6, roughness: 0.35, metalness: 0.05 });
      const stripes = 10;
      const step = length / stripes;
      for (let i = 0; i < stripes; i++) {
        const m = new THREE.Mesh(new THREE.PlaneGeometry(width, step * 0.65), stripeMat);
        m.rotation.x = -Math.PI / 2;
        m.position.z = -length / 2 + i * step + step / 2;
        m.position.y = 0.02;
        group.add(m);
      }
      group.position.set(x, 0, z);
      group.rotation.y = rot;
      scene.add(group);
    }

    crosswalkRect(0, 0, 12, 34, 0);
    crosswalkRect(0, 0, 12, 34, Math.PI / 2);
    crosswalkRect(0, 0, 11, 34, Math.PI / 4);
    crosswalkRect(0, 0, 11, 34, -Math.PI / 4);

    const laneMark = new THREE.MeshStandardMaterial({ color: 0xd7d08f, roughness: 0.45, metalness: 0.02 });
    function addRoadStripe(x1, z1, x2, z2) {
      const dx = x2 - x1;
      const dz = z2 - z1;
      const len = Math.sqrt(dx * dx + dz * dz);
      const m = new THREE.Mesh(new THREE.PlaneGeometry(0.34, len), laneMark);
      m.rotation.x = -Math.PI / 2;
      m.rotation.z = Math.atan2(dx, dz);
      m.position.set((x1 + x2) / 2, 0.021, (z1 + z2) / 2);
      scene.add(m);
    }
    addRoadStripe(-100, -6, 100, -6);
    addRoadStripe(-100, 6, 100, 6);
    addRoadStripe(-6, -100, -6, 100);
    addRoadStripe(6, -100, 6, 100);

    function makeBuildingTexture(seedColor = '#0f172f') {
      const c = document.createElement('canvas');
      c.width = 512;
      c.height = 1024;
      const g = c.getContext('2d');
      g.fillStyle = seedColor;
      g.fillRect(0, 0, c.width, c.height);
      for (let y = 10; y < c.height - 20; y += 32) {
        for (let x = 8; x < c.width - 10; x += 28) {
          const on = Math.random() > 0.35;
          g.fillStyle = on
            ? `rgba(${180 + Math.random() * 70},${170 + Math.random() * 60},${130 + Math.random() * 90},${0.70 + Math.random() * 0.25})`
            : `rgba(16,22,33,0.85)`;
          g.fillRect(x, y, 16, 20);
        }
      }
      return new THREE.CanvasTexture(c);
    }

    function createBillboard(text, color = '#5df0ff', bg = '#0b1235') {
      const c = document.createElement('canvas');
      c.width = 1024;
      c.height = 512;
      const g = c.getContext('2d');
      g.fillStyle = bg;
      g.fillRect(0, 0, c.width, c.height);
      const grad = g.createLinearGradient(0, 0, c.width, c.height);
      grad.addColorStop(0, 'rgba(255,255,255,0.1)');
      grad.addColorStop(1, 'rgba(255,255,255,0)');
      g.fillStyle = grad;
      g.fillRect(0, 0, c.width, c.height);
      g.strokeStyle = 'rgba(255,255,255,0.22)';
      g.lineWidth = 8;
      g.strokeRect(10, 10, c.width - 20, c.height - 20);
      g.font = 'bold 96px Arial, sans-serif';
      g.fillStyle = color;
      g.textAlign = 'center';
      g.shadowColor = color;
      g.shadowBlur = 25;
      g.fillText(text, c.width / 2, c.height / 2 + 10);
      g.font = '48px Arial, sans-serif';
      g.fillStyle = '#ffffffcc';
      g.fillText('渋谷スクランブル交差点', c.width / 2, c.height / 2 + 96);
      const tex = new THREE.CanvasTexture(c);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      return tex;
    }

    const buildings = new THREE.Group();
    scene.add(buildings);

    function addBuilding(x, z, w, h, d) {
      const mat = new THREE.MeshStandardMaterial({ map: makeBuildingTexture(), roughness: 0.72, metalness: 0.15, emissive: 0x111626, emissiveIntensity: 0.6 });
      const building = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
      building.position.set(x, h / 2, z);
      building.castShadow = true;
      building.receiveShadow = true;
      buildings.add(building);

      if (Math.random() > 0.35) {
        const signTex = createBillboard('TOKYO VISION', ['#66ecff','#f055ff','#ffe56f'][Math.floor(Math.random() * 3)], ['#081744','#2f0b3e','#421804'][Math.floor(Math.random() * 3)]);
        const sign = new THREE.Mesh(
          new THREE.PlaneGeometry(w * 0.8, h * 0.25),
          new THREE.MeshStandardMaterial({ map: signTex, emissive: 0x88aaff, emissiveMap: signTex, emissiveIntensity: 0.55, roughness: 0.25, metalness: 0.2, side: THREE.DoubleSide })
        );
        sign.position.set(x + (Math.random() > 0.5 ? w / 2 + 0.1 : -w / 2 - 0.1), h * 0.58, z);
        sign.rotation.y = sign.position.x > x ? -Math.PI / 2 : Math.PI / 2;
        buildings.add(sign);
      }
    }

    const ring = 120;
    for (let i = 0; i < 54; i++) {
      const angle = (i / 54) * Math.PI * 2;
      const radius = ring + (Math.random() * 18 - 9);
      const x = Math.cos(angle) * radius;
      const z = Math.sin(angle) * radius;
      const w = 10 + Math.random() * 18;
      const d = 9 + Math.random() * 16;
      const h = 30 + Math.random() * 86;
      addBuilding(x, z, w, h, d);
    }

    const traffic = { mode: 'cars', timer: 0, cycle: 24 };

    function makeTrafficLight(x, z, rot, dir = 'x') {
      const group = new THREE.Group();
      const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.2, 6.4, 10), new THREE.MeshStandardMaterial({ color: 0x222831, metalness: 0.75, roughness: 0.38 }));
      pole.position.y = 3.2;
      group.add(pole);

      const housing = new THREE.Mesh(new THREE.BoxGeometry(0.9, 2.2, 0.62), new THREE.MeshStandardMaterial({ color: 0x12161b, metalness: 0.65, roughness: 0.3 }));
      housing.position.set(0, 5.4, 0);
      group.add(housing);

      const lamps = [];
      const colors = [0xff2a32, 0xffdb3a, 0x3cff76];
      for (let i = 0; i < 3; i++) {
        const emissive = new THREE.MeshStandardMaterial({ color: colors[i], emissive: colors[i], emissiveIntensity: i === 0 ? 2.4 : 0.08 });
        const lamp = new THREE.Mesh(new THREE.SphereGeometry(0.16, 18, 18), emissive);
        lamp.position.set(0, 6.0 - i * 0.62, 0.33);
        lamps.push(lamp);
        group.add(lamp);
      }

      group.position.set(x, 0, z);
      group.rotation.y = rot;
      scene.add(group);
      return { dir, lamps };
    }

    const trafficLights = [
      makeTrafficLight(11, -11, Math.PI, 'x'),
      makeTrafficLight(-11, 11, 0, 'x'),
      makeTrafficLight(11, 11, -Math.PI / 2, 'z'),
      makeTrafficLight(-11, -11, Math.PI / 2, 'z')
    ];

    function updateTrafficLights() {
      for (const light of trafficLights) {
        const carGreen = traffic.mode === (light.dir === 'x' ? 'cars' : 'pedestrians');
        light.lamps[0].material.emissiveIntensity = carGreen ? 0.1 : 2.6;
        light.lamps[1].material.emissiveIntensity = 0.08;
        light.lamps[2].material.emissiveIntensity = carGreen ? 2.1 : 0.08;
      }
    }

    const carLaneData = [
      { axis: 'x', y: 0.65, z: -4.2, dir: 1 },
      { axis: 'x', y: 0.65, z: 4.2, dir: -1 },
      { axis: 'z', y: 0.65, x: -4.2, dir: -1 },
      { axis: 'z', y: 0.65, x: 4.2, dir: 1 }
    ];

    function createCar(color) {
      const car = new THREE.Group();
      const body = new THREE.Mesh(new THREE.BoxGeometry(3.2, 1.0, 1.8), new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.6 }));
      body.position.y = 0.85;
      body.castShadow = true;
      car.add(body);

      const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.72, 1.55), new THREE.MeshStandardMaterial({ color: 0x263238, roughness: 0.2, metalness: 0.8 }));
      cabin.position.set(0.2, 1.45, 0);
      cabin.castShadow = true;
      car.add(cabin);

      for (const wx of [-1.1, 1.1]) {
        for (const wz of [-0.8, 0.8]) {
          const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.34, 0.34, 0.26, 18), new THREE.MeshStandardMaterial({ color: 0x101113, roughness: 0.9 }));
          wheel.rotation.z = Math.PI / 2;
          wheel.position.set(wx, 0.35, wz);
          car.add(wheel);
        }
      }
      return car;
    }

    const cars = [];
    const carColors = [0x8be4ff, 0xffa952, 0xdbe4f7, 0xff668a, 0x8bffa1, 0x8f9dff];
    for (let i = 0; i < 18; i++) {
      const lane = carLaneData[i % carLaneData.length];
      const car = createCar(carColors[i % carColors.length]);
      car.userData = {
        lane,
        speed: 8 + Math.random() * 6,
        t: -120 + i * 14,
      };
      if (lane.axis === 'x') {
        car.position.set(car.userData.t * lane.dir, lane.y, lane.z);
        car.rotation.y = lane.dir > 0 ? -Math.PI / 2 : Math.PI / 2;
      } else {
        car.position.set(lane.x, lane.y, car.userData.t * lane.dir);
        car.rotation.y = lane.dir > 0 ? Math.PI : 0;
      }
      scene.add(car);
      cars.push(car);
    }

    function createPedestrian(color = 0xd3d7e5) {
      const npc = new THREE.Group();
      const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.28, 1.05, 6, 14), new THREE.MeshStandardMaterial({ color, roughness: 0.7 }));
      body.position.y = 1.08;
      body.castShadow = true;
      npc.add(body);
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.24, 16, 16), new THREE.MeshStandardMaterial({ color: 0xf4c7a5, roughness: 0.82 }));
      head.position.y = 1.96;
      head.castShadow = true;
      npc.add(head);
      return npc;
    }

    const pedestrianPaths = [
      { from: new THREE.Vector3(-18, 0, 0), to: new THREE.Vector3(18, 0, 0) },
      { from: new THREE.Vector3(18, 0, 0), to: new THREE.Vector3(-18, 0, 0) },
      { from: new THREE.Vector3(0, 0, -18), to: new THREE.Vector3(0, 0, 18) },
      { from: new THREE.Vector3(0, 0, 18), to: new THREE.Vector3(0, 0, -18) },
      { from: new THREE.Vector3(-16, 0, -16), to: new THREE.Vector3(16, 0, 16) },
      { from: new THREE.Vector3(16, 0, -16), to: new THREE.Vector3(-16, 0, 16) }
    ];

    const pedestrians = [];
    for (let i = 0; i < 80; i++) {
      const p = createPedestrian(new THREE.Color().setHSL(0.55 + Math.random() * 0.45, 0.15 + Math.random() * 0.5, 0.45 + Math.random() * 0.25));
      const path = pedestrianPaths[i % pedestrianPaths.length];
      const phase = Math.random();
      p.userData = {
        path,
        progress: phase,
        speed: 0.12 + Math.random() * 0.12,
        bob: Math.random() * Math.PI * 2
      };
      p.position.copy(path.from.clone().lerp(path.to, phase));
      p.lookAt(path.to.x, 1.3, path.to.z);
      scene.add(p);
      pedestrians.push(p);
    }

    const keyState = { w: false, a: false, s: false, d: false, shift: false, space: false };
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let canJump = false;
    const eyeHeight = 1.72;

    document.addEventListener('keydown', (e) => {
      if (e.code === 'KeyW') keyState.w = true;
      if (e.code === 'KeyA') keyState.a = true;
      if (e.code === 'KeyS') keyState.s = true;
      if (e.code === 'KeyD') keyState.d = true;
      if (e.code === 'ShiftLeft') keyState.shift = true;
      if (e.code === 'Space') {
        keyState.space = true;
        if (canJump && controls.isLocked) {
          velocity.y = 6.8;
          canJump = false;
        }
      }
    });
    document.addEventListener('keyup', (e) => {
      if (e.code === 'KeyW') keyState.w = false;
      if (e.code === 'KeyA') keyState.a = false;
      if (e.code === 'KeyS') keyState.s = false;
      if (e.code === 'KeyD') keyState.d = false;
      if (e.code === 'ShiftLeft') keyState.shift = false;
      if (e.code === 'Space') keyState.space = false;
    });

    const clock = new THREE.Clock();

    function updateCars(dt) {
      const carsGreen = traffic.mode === 'cars';
      for (const car of cars) {
        const { lane, speed } = car.userData;
        const axisPos = lane.axis === 'x' ? car.position.x : car.position.z;
        const nearCenter = Math.abs(axisPos) < 18;
        const shouldStop = !carsGreen && nearCenter;
        const currentSpeed = shouldStop ? 0.0 : speed;
        const delta = currentSpeed * lane.dir * dt;

        if (lane.axis === 'x') {
          car.position.x += delta;
          if (car.position.x > 150) car.position.x = -150;
          if (car.position.x < -150) car.position.x = 150;
        } else {
          car.position.z += delta;
          if (car.position.z > 150) car.position.z = -150;
          if (car.position.z < -150) car.position.z = 150;
        }
      }
    }

    function updatePedestrians(dt) {
      const walk = traffic.mode === 'pedestrians';
      for (const npc of pedestrians) {
        if (walk) {
          npc.userData.progress += npc.userData.speed * dt;
          if (npc.userData.progress > 1) {
            npc.userData.progress = 0;
            const oldFrom = npc.userData.path.from;
            npc.userData.path.from = npc.userData.path.to;
            npc.userData.path.to = oldFrom;
            npc.lookAt(npc.userData.path.to.x, 1.3, npc.userData.path.to.z);
          }
          npc.position.copy(npc.userData.path.from.clone().lerp(npc.userData.path.to, npc.userData.progress));
        }
        npc.userData.bob += dt * 9;
        npc.position.y = Math.max(0, Math.sin(npc.userData.bob) * 0.02);
      }
    }

    function updateTrafficCycle(dt) {
      traffic.timer += dt;
      if (traffic.timer >= traffic.cycle) {
        traffic.timer = 0;
        traffic.mode = traffic.mode === 'cars' ? 'pedestrians' : 'cars';
      }
      updateTrafficLights();
      hud.textContent = `Estado: ${controls.isLocked ? 'Explorando' : 'Pausado'} · Semáforo: ${traffic.mode === 'cars' ? 'coches en marcha' : 'peatones cruzando'} · Ciclo ${(traffic.cycle - traffic.timer).toFixed(0)}s`;
    }

    updateTrafficLights();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);

      updateTrafficCycle(dt);
      updateCars(dt);
      updatePedestrians(dt);

      if (controls.isLocked) {
        velocity.x -= velocity.x * 8 * dt;
        velocity.z -= velocity.z * 8 * dt;
        velocity.y -= 18.5 * dt;

        direction.z = Number(keyState.w) - Number(keyState.s);
        direction.x = Number(keyState.d) - Number(keyState.a);
        direction.normalize();

        const speed = keyState.shift ? 18 : 11;
        if (keyState.w || keyState.s) velocity.z -= direction.z * speed * dt * 12;
        if (keyState.a || keyState.d) velocity.x -= direction.x * speed * dt * 12;

        controls.moveRight(-velocity.x * dt);
        controls.moveForward(-velocity.z * dt);
        controls.getObject().position.y += velocity.y * dt;

        if (controls.getObject().position.y < eyeHeight) {
          velocity.y = 0;
          controls.getObject().position.y = eyeHeight;
          canJump = true;
        }

        const p = controls.getObject().position;
        p.x = THREE.MathUtils.clamp(p.x, -worldBounds, worldBounds);
        p.z = THREE.MathUtils.clamp(p.z, -worldBounds, worldBounds);
      }

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
